from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from rest_framework.permissions import IsAdminUser, AllowAny
from django.contrib.auth import authenticate, login, logout
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator
from django.db.models import Sum, Avg, Q
from .models import Tenant, Volume
from .serializers import TenantSerializer, VolumeSerializer
import pandas as pd
import logging
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator

logger = logging.getLogger(__name__)

@method_decorator(csrf_exempt, name='dispatch')
@method_decorator(csrf_exempt, name='dispatch')
    permission_classes = [IsAdminUser]

    def post(self, request):
        username = request.data.get('username')
        password = request.data.get('password')
        user = authenticate(username=username, password=password)
        if user:
            login(request, user)
            return Response({'status': 'success', 'is_admin': user.is_superuser})
        return Response({'status': 'failure', 'error': 'Invalid credentials'}, status=status.HTTP_400_BAD_REQUEST)

class LogoutView(APIView):
    def post(self, request):
        logout(request)
        return Response({'status': 'success'})

class ImportDataView(APIView):
    permission_classes = [IsAdminUser]

    def post(self, request):
        file = request.FILES.get('file')
        if not file:
            return Response({'error': 'No file uploaded'}, status=status.HTTP_400_BAD_REQUEST)

        try:
            # Read file
            if file.name.endswith('.xlsx'):
                df = pd.read_excel(file, sheet_name=0)
            elif file.name.endswith('.csv'):
                df = pd.read_csv(file)
            else:
                return Response({'error': 'Unsupported file type. Please upload .xlsx or .csv'}, status=status.HTTP_400_BAD_REQUEST)

            # Rename Pool to Child Pool if needed
            if 'Pool' in df.columns:
                df = df.rename(columns={'Pool': 'Child Pool'})

            # Select key columns
            required_columns = ['Volume', 'System', 'Volume Size (GB)', 'Written by Host (%)', 'Child Pool']
            missing_cols = [col for col in required_columns if col not in df.columns]
            if missing_cols:
                return Response({'error': f'Missing columns: {missing_cols}'}, status=status.HTTP_400_BAD_REQUEST)
            
            df = df[required_columns]

            # Clean data
            df['Volume Size (GB)'] = pd.to_numeric(df['Volume Size (GB)'], errors='coerce').fillna(0)
            df['Written by Host (%)'] = pd.to_numeric(df['Written by Host (%)'], errors='coerce').fillna(0) / 100
            df = df[df['Volume Size (GB)'] >= 0]  # Remove negative values

            # Extract Tenant from Volume name
            def extract_tenant(volume):
                parts = str(volume).split('_')
                if len(parts) > 1:
                    return '_'.join(parts[:-1])
                return volume

            df['Tenant'] = df['Volume'].apply(extract_tenant)
            df['Utilized GB'] = df['Written by Host (%)'] * df['Volume Size (GB)']
            df['Left GB'] = df['Volume Size (GB)'] - df['Utilized GB']

            # Aggregate by Tenant
            agg = df.groupby('Tenant').agg({
                'Volume Size (GB)': 'sum',
                'Utilized GB': 'sum',
                'Left GB': 'sum',
                'Written by Host (%)': 'mean',
                'System': 'first',
                'Child Pool': 'first'
            }).reset_index()
            
            agg.rename(columns={
                'Volume Size (GB)': 'allocated_gb',
                'Utilized GB': 'utilized_gb',
                'Left GB': 'left_gb',
                'Written by Host (%)': 'avg_utilization'
            }, inplace=True)

            # Clear old data
            Tenant.objects.all().delete()

            # Save tenants
            for _, row in agg.iterrows():
                Tenant.objects.create(
                    name=row['Tenant'],
                    system=row['System'],
                    child_pool=row['Child Pool'],
                    allocated_gb=row['allocated_gb'],
                    utilized_gb=row['utilized_gb'],
                    left_gb=row['left_gb'],
                    avg_utilization=row['avg_utilization']
                )

            # Save volumes
            for _, row in df.iterrows():
                tenant = Tenant.objects.get(name=row['Tenant'])
                Volume.objects.create(
                    tenant=tenant,
                    volume=row['Volume'],
                    system=row['System'],
                    volume_size_gb=row['Volume Size (GB)'],
                    written_by_host_percent=row['Written by Host (%)'],
                    child_pool=row['Child Pool'],
                    utilized_gb=row['Utilized GB'],
                    left_gb=row['Left GB']
                )

            return Response({
                'status': 'success',
                'message': f'Successfully imported {len(agg)} tenants and {len(df)} volumes'
            })

        except Exception as e:
            logger.error(f'Error processing file: {e}')
            return Response({'error': str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

class DashboardView(APIView):
    def get(self, request):
        pool_filter = request.query_params.get('pool')
        tenant_filter = request.query_params.get('tenant')

        if tenant_filter:
            # Volume level - show volumes for specific tenant
            volumes = Volume.objects.filter(tenant__name=tenant_filter)
            data = VolumeSerializer(volumes, many=True).data
            return Response({
                'level': 'volumes',
                'data': data,
                'tenant': tenant_filter
            })

        elif pool_filter:
            # Tenant level - show tenants for specific pool
            tenants = Tenant.objects.filter(child_pool=pool_filter)
            data = TenantSerializer(tenants, many=True).data
            return Response({
                'level': 'tenants',
                'data': data,
                'pool': pool_filter
            })

        else:
            # Overall level - show summary and pools
            overall = Tenant.objects.aggregate(
                allocated_tb=Sum('allocated_gb') / 1024,
                utilized_tb=Sum('utilized_gb') / 1024,
                left_tb=Sum('left_gb') / 1024,
                avg_util=Avg('avg_utilization')
            )
            
            pools = Tenant.objects.values('child_pool').annotate(
                allocated_tb=Sum('allocated_gb') / 1024,
                utilized_tb=Sum('utilized_gb') / 1024,
                left_tb=Sum('left_gb') / 1024,
                avg_util=Avg('avg_utilization')
            ).order_by('-utilized_tb')
            
            top_tenants = Tenant.objects.order_by('-utilized_gb')[:10]
            top_tenants_data = TenantSerializer(top_tenants, many=True).data

            return Response({
                'level': 'overall',
                'overall': overall,
                'pools': list(pools),
                'top_tenants': top_tenants_data
            })
